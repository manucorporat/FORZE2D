// DO NOT MODIFY THE HEADERS IF FORZE IS ALREADY COMPILED AS A STATIC LIBRARY
#ifndef __FZPARTICLESYSTEM_H_INCLUDED__
#define __FZPARTICLESYSTEM_H_INCLUDED__
/*
 * FORZE ENGINE: http://forzefield.com
 *
 * Copyright (c) 2011-2012 FORZEFIELD Studios S.L.
 * Copyright (c) 2012 Manuel Martínez-Almeida
 * Copyright (c) 2008-2010 Ricardo Quesada
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 @author Manuel Martínez-Almeida
 */

#include "FZProtocols.h"
#include "FZNode.h"


//using namespace STD;

namespace FORZE {
    
    //! @enum
    enum {
        //! The Particle emitter lives forever
        kFZParticleDurationInfinity = -1,
        
        //! The starting size of the particle is equal to the ending size
        kFZParticleStartSizeEqualToEndSize = -1,
        
        //! The starting radius of the particle is equal to the ending radius
        kFZParticleStartRadiusEqualToEndRadius = -1,
    };
    
    //! @enum
    enum {
        //! Gravity mode (A mode)
        kFZParticleModeGravity,
        
        //! Radius mode (B mode)
        kFZParticleModeRadius,	
    };
    
    
    /** @typedef tCCPositionType
     possible types of particle positions
     */
    typedef enum {
        /** Living particles are attached to the world and are unaffected by emitter repositioning. */
        kFZPositionTypeFree,
        
        /** Living particles are attached to the world but will follow the emitter repositioning.
         Use case: Attach an emitter to an sprite, and you want that the emitter follows the sprite.
         */
        kFZPositionTypeRelative,
        
        /** Living particles are attached to the emitter and are translated along with it. */
        kFZPositionTypeGrouped,
    }tFZPositionType;
    
    
    struct fzParticle {
        fzPoint		pos;
        fzSize      size;
        fzColor4B   color;
        fzFloat		rotation;
    };
    
    
    class ParticleSystemLogic
    {
    public:
        virtual ~ParticleSystemLogic() {}
        virtual void updateParticle(fzUInt index, fzFloat dt, fzParticle *particle) = 0;
        virtual void preUpdate(fzFloat dt) = 0;
        virtual fzUInt getParticleCount() const = 0;
        virtual fzUInt getTotalParticles() const = 0;

    };
    
    
    /** Particle System base class
     Attributes of a Particle System:
     - emmision rate of the particles
     - Gravity Mode (Mode A):
     - gravity
     - direction
     - speed +-  variance
     - tangential acceleration +- variance
     - radial acceleration +- variance
     - Radius Mode (Mode B):
     - startRadius +- variance
     - endRadius +- variance
     - rotate +- variance
     - Properties common to all modes:
     - life +- life variance
     - start spin +- variance
     - end spin +- variance
     - start size +- variance
     - end size +- variance
     - start color +- variance
     - end color +- variance
     - life +- variance
     - blending function
     - texture
     
     FORZE also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).
     'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in FORZE,
     FORZE uses a another approach, but the results are almost identical.
     
     FORZE supports all the variables used by Particle Designer plus a bit more:
     - spinning particles (supported when using ParticleSystemQuad)
     - tangential acceleration (Gravity mode)
     - radial acceleration (Gravity mode)
     - radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only)
     
     It is possible to customize any of the above mentioned properties in runtime. Example:
     
     @code
     emitter.radialAccel = 15;
     emitter.startSpin = 0;
     @endcode
     
     */
    class ParticleSystem : public ParticleSystemLogic
    {
    protected:
        
        struct fztParticle {
            fzPoint		pos;
            
            fzColor4F   color;
            fzColor4F   deltaColor;
            
            fzFloat		size;
            fzFloat		deltaSize;
            
            fzFloat		rotation;
            fzFloat		deltaRotation;
            
            fzFloat		timeToLive;
            
            union {
                // Mode A: gravity, direction, radial accel, tangential accel
                struct {
                    fzPoint     dir;
                    fzFloat		radialAccel;
                    fzFloat		tangentialAccel;
                } A;
                
                // Mode B: radius mode
                struct {
                    fzFloat		angle;
                    fzFloat		degreesPerSecond;
                    fzFloat		radius;
                    fzFloat		deltaRadius;
                } B;
            } mode;
        };
        
        // Start color of the particles
        fzColor4F m_startColor;
        // Start color variance
        fzColor4F m_startColorVar;
        // End color of the particles
        fzColor4F m_endColor;
        // End color variance
        fzColor4F m_endColorVar;
        
        // position is from "superclass" CocosNode
        fzPoint m_sourcePosition;
        // Position variance
        fzPoint m_posVar;
        
        // is the particle system active ?
        fzFloat m_isActive;
        // duration in seconds of the system. -1 is infinity
        fzFloat m_duration;
        // time elapsed since the start of the system (in seconds)
        fzFloat m_elapsed;
        // The angle (direction) of the particles measured in degrees
        fzFloat m_angle;
        // Angle variance measured in degrees;
        fzFloat m_angleVar;
        
        // start ize of the particles
        fzFloat m_startSize;
        // start Size variance
        fzFloat m_startSizeVar;
        // End size of the particle
        fzFloat m_endSize;
        // end size of variance
        fzFloat m_endSizeVar;
        
        // How many seconds will the particle live
        fzFloat m_life;
        // Life variance
        fzFloat m_lifeVar;
        
        // start angle of the particles
        fzFloat m_startSpin;
        // start angle variance
        fzFloat m_startSpinVar;
        // End angle of the particle
        fzFloat m_endSpin;
        // end angle ariance
        fzFloat m_endSpinVar;
        
        // Different modes
        fzInt m_emitterMode;
        
        union {
            // Mode A:Gravity + Tangential Accel + Radial Accel
            struct {
                fzPoint gravity;
                fzFloat speed;
                fzFloat speedVar;
                fzFloat tangentialAccel;
                fzFloat tangentialAccelVar;
                fzFloat radialAccel;
                fzFloat radialAccelVar;
            } A;
            
            // Mode B: circular movement
            struct {
                fzFloat startRadius;
                fzFloat startRadiusVar;
                fzFloat endRadius;
                fzFloat endRadiusVar;			
                fzFloat rotatePerSecond;
                fzFloat rotatePerSecondVar;
            } B;
        } mode;
        
        

        // Maximum particles
        fzUInt m_totalParticles;
        // Count of active particles
        fzUInt m_particleCount;
        //  particle idx
        fzUInt m_particleIdx;
        

        // How many particles can be emitted per second
        fzFloat m_emissionRate;
        fzFloat m_emitCounter;
        
        // Array of particles
        fztParticle *p_particles;
        
        // movment type: free or grouped
        tFZPositionType	m_positionType;
        
        // Whether or not the node will be auto-removed when there are not particles
        bool	m_autoRemoveOnFinish;
    
        
    public:
        /** initializes a ParticleSystem from a plist file.
         This plist files can be creted manually or with Particle Designer:
         http://particledesigner.71squared.com/
         */
        //ParticleSystem(const STD::string& plistFile);
        
        //! initializes a CCQuadParticleSystem from a NSDictionary.
        //ParticleSystem(const std::map& dictionary);
        
        //! Initializes a system with a fixed number of particles
        ParticleSystem(fzUInt numberOfParticles);
        
        // Destructor
        ~ParticleSystem();
        
        //! Add a particle to the emitter
        bool addParticle();
        
        //! Initializes a particle
        void initParticle(fztParticle& particle);
        
        //! stop emitting particles. Running particles will continue to run until they die
        void stopSystem();
        
        //! Kill all living particles.
        void resetSystem();
        
        //! whether or not the system is full
        bool isFull() const;
        
        //! should be overriden by subclasses
        
#if FZ_VBO_STREAMING
        //! should be overriden by subclasses
        virtual void postStep() = 0;
#endif
        
        //! called in every loop.
        void update(fzFloat dt);
        
        //! Is the emitter active
        void setIsActive(bool a) {
            m_isActive = a;
        }
        
        bool getIsActive() const {
            return m_isActive;
        }
        
        
        virtual void updateParticle(fzUInt index, fzFloat dt, fzParticle *particle) override;
        virtual void preUpdate(fzFloat dt) override;
        virtual fzUInt getParticleCount() const override;
        virtual fzUInt getTotalParticles() const override;
        
        //! How many seconds the emitter wil run. -1 means 'forever'
        void setDuration(fzFloat duration) {
            m_duration = duration;
        }
        
        fzFloat getDuration() const {
            return m_duration;
        }
        
        
        //! sourcePosition of the emitter
        void setSourcePosition(const fzPoint& source) {
            m_sourcePosition = source;
        }
        
        const fzPoint& getSourcePosition() const {
            return m_sourcePosition;
        }
        
        
        //! Position variance of the emitter
        void setPosVar(const fzPoint& posVar) {
            m_posVar = posVar;
        }
        
        const fzPoint& getPosVar() const {
            return m_posVar;
        }
        
        
        //! life, and life variation of each particle
        void setLife(fzFloat life) {
            m_life = life;
        }
        
        fzFloat getLife() const {
            return m_life;
        }
        
        
        //! life variance of each particle
        void setLifeVar(fzFloat lifeVar) {
            m_lifeVar = lifeVar;
        }
        
        fzFloat getLifeVar() const {
            return m_lifeVar;
        }
        
        
        //! angle and angle variation of each particle
        void setAngle(fzFloat angle) {
            m_angle = angle;
        }
        
        fzFloat getAngle() const {
            return m_angle;
        }
        
        
        //! angle variance of each particle
        void setAngleVar(fzFloat angleVar) {
            m_angleVar = angleVar;
        }
        
        fzFloat getAngleVar() const {
            return m_angleVar;
        }
        
        
        //! Gravity value. Only available in 'Gravity' mode
        void setGravity(const fzPoint&);
        const fzPoint& getGravity() const;
        
        //! speed of each particle. Only available in 'Gravity' mode
        void setSpeed(fzFloat);
        fzFloat getSpeed() const;
        
        //! speed variance of each particle. Only available in 'Gravity' mode
        void setSpeedVar(fzFloat);
        fzFloat getSpeedVar() const;
        
        //! tangential acceleration of each particle. Only available in 'Gravity' mode
        void setTangentialAccel(fzFloat);
        fzFloat getTangentialAccel() const;
        
        //! tangential acceleration variance of each particle. Only available in 'Gravity' mode
        void setTangentialAccelVar(fzFloat);
        fzFloat getTangentialAccelVar() const;
        
        //! radial acceleration of each particle. Only available in 'Gravity' mode
        void setRadialAccel(fzFloat);
        fzFloat getRadialAccel() const;
        
        //! radial acceleration variance of each particle. Only available in 'Gravity' mode
        void setRadialAccelVar(fzFloat);
        fzFloat getRadialAccelVar() const;
        
        //! The starting radius of the particles. Only available in 'Radius' mode
        void setStartRadius(fzFloat);
        fzFloat getStartRadius() const;
        
        //! The starting radius variance of the particles. Only available in 'Radius' mode
        void setStartRadiusVar(fzFloat);
        fzFloat getStartRadiusVar() const;
        
        //! The ending radius of the particles. Only available in 'Radius' mode
        void setEndRadius(fzFloat);
        fzFloat getEndRadius() const;
        
        //! The ending radius variance of the particles. Only available in 'Radius' mode
        void setEndRadiusVar(fzFloat);
        fzFloat getEndRadiusVar() const;
        
        //! Number of degress to rotate a particle around the source pos per second. Only available in 'Radius' mode.
        void setRotatePerSecond(fzFloat);
        fzFloat getRotatePerSecond() const;
        
        //! Variance in degrees for rotatePerSecond. Only available in 'Radius' mode.
        void setRotatePerSecondVar(fzFloat r);
        fzFloat getRotatePerSecondVar() const;
        
        
        //! start size in pixels of each particle
        void setStartSize(fzFloat s) {
            m_startSize = s;
        }
        
        fzFloat getStartSize() const {
            return m_startSize;
        }
        
        
        //! size variance in pixels of each particle
        void setStartSizeVar(fzFloat s) {
            m_startSizeVar = s;
        }
        
        fzFloat getStartSizeVar() const {
            return m_startSizeVar;
        }
        
        
        //! end size in pixels of each particle
        void setEndSize(fzFloat s) {
            m_endSize = s;
        }
        
        fzFloat getEndSize() const {
            return m_endSize;
        }
        
        
        //! end size variance in pixels of each particle
        void setEndSizeVar(fzFloat s) {
            m_endSizeVar = s;
        }
        
        fzFloat getEndSizeVar() const {
            return m_endSizeVar;
        }
        
        
        //! start color of each particle
        void setStartColor(const fzColor4F& c) {
            m_startColor = c;
        }
        
        const fzColor4F& getStartColor() const {
            return m_startColor;
        }
        
        
        //! start color variance of each particle
        void setStartColorVar(const fzColor4F& c) {
            m_startColorVar = c;
        }
        
        const fzColor4F& getStartColorVar() const {
            return m_startColorVar;
        }
        
        
        //! end color and end color variation of each particle
        void setEndColor(const fzColor4F& c) {
            m_endColor = c;
        }
        
        const fzColor4F& getEndColor() const {
            return m_endColor;
        }
        
        
        //! end color variance of each particle
        void setEndColorVar(const fzColor4F& c) {
            m_endColorVar = c;
        }
        
        const fzColor4F& getEndColorVar() const {
            return m_endColorVar;
        }
        
        
        //! initial angle of each particle
        void setStartSpin(fzFloat s) {
            m_startSpin = s;
        }
        
        fzFloat getStartSpin() const {
            return m_startSpin;
        }
        
        
        //! initial angle of each particle
        void setStartSpinVar(fzFloat s) {
            m_startSpinVar = s;
        }
        
        fzFloat getStartSpinVar() const {
            return m_startSpinVar;
        }
        
        
        //! initial angle of each particle
        void setEndSpin(fzFloat s) {
            m_endSpin = s;
        }
        
        fzFloat getEndSpin() const {
            return m_endSpin;
        }
        
        
        //! initial angle of each particle
        void setEndSpinVar(fzFloat s) {
            m_endSpinVar = s;
        }
        
        fzFloat getEndSpinVar() const {
            return m_endSpinVar;
        }
        
        
        //! emission rate of the particles
        void setEmissionRate(fzFloat r) {
            m_emissionRate = r;
        }
        
        fzFloat getEmissionRate() const {
            return m_emissionRate;
        }

        //! particles movement type: Free or Grouped
        void setPositionType(tFZPositionType e) {
            m_positionType = e;
        }
        
        tFZPositionType getPositionType() const {
            return m_positionType;
        }
        //! whether or not the node will be auto-removed when it has no particles left
        void setAutoRemoveOnFinish(bool a) {
            m_autoRemoveOnFinish = a;
        }
        
        bool getAutoRemoveOnFinish() const {
            return m_autoRemoveOnFinish;
        }
        
        /** Switch between different kind of emitter modes:
         - kCCParticleModeGravity: uses gravity, speed, radial and tangential acceleration
         - kCCParticleModeRadius: uses radius movement + rotation
         */
        void setEmitterMode(fzInt e) {
            m_emitterMode = e;
        }
        
        fzInt getEmitterMode() const {
            return m_emitterMode;
        }
    };
}
#endif
